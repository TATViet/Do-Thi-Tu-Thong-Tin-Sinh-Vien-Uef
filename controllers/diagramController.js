// controllers/diagramController.js (WITH CACHING LIKE allStudentsProgressController.js)

const TieuChiDauRa = require('../models/tieuChiDauRa');
const MonHocTieuChi = require('../models/MonHocTieuChi');
const HienDienSV = require('../models/HienDienSV');
const DiemSinhVien = require('../models/DiemSinhVien');
const ChuongTrinh = require('../models/ChuongTrinh');
const ploProgressController = require('./ploProgressController');

// Cache cho diagram data
const diagramCache = new Map();

function getDiagramCacheKey(maKhoi) {
  return `diagram_${maKhoi}`;
}

function saveDiagramToCache(maKhoi, data) {
  const key = getDiagramCacheKey(maKhoi);
  const cacheData = {
    timestamp: Date.now(),
    data: data
  };
  diagramCache.set(key, cacheData);
  console.log(`üíæ ƒê√£ cache diagram cho kh·ªëi ${maKhoi}`);
}

function loadDiagramFromCache(maKhoi) {
  const key = getDiagramCacheKey(maKhoi);
  const cacheData = diagramCache.get(key);
  
  if (cacheData) {
    const ageMinutes = (Date.now() - cacheData.timestamp) / (1000 * 60);
    console.log(`üìÅ T·∫£i cache diagram kh·ªëi ${maKhoi} (${ageMinutes.toFixed(1)} ph√∫t tr∆∞·ªõc)`);
    return cacheData.data;
  }
  return null;
}

exports.getDiagramForm = async (req, res) => {
  try {
    res.render('index', { 
      title: 'Bi·ªÉu ƒë·ªì PLO',
      diagramMode: true,
      showSearchSection: false,
      sinhVienSearchMode: false,
      diemSinhVienSearchMode: false,
      ploProgressMode: false,
      allStudentsProgressMode: false
    });
  } catch (error) {
    console.error('Error loading diagram form:', error);
    res.render('index', { 
      title: 'Bi·ªÉu ƒë·ªì PLO',
      error: 'ƒê√£ x·∫£y ra l·ªói khi t·∫£i trang bi·ªÉu ƒë·ªì.',
      diagramMode: true,
      showSearchSection: false
    });
  }
};

exports.generateDiagram = async (req, res) => {
  const startTime = Date.now();
  
  try {
    const maKhoi = req.body.maKhoi;
    
    if (!maKhoi) {
      return res.render('index', {
        title: 'Bi·ªÉu ƒë·ªì PLO',
        diagramMode: true,
        maKhoiQuery: '',
        error: 'Vui l√≤ng nh·∫≠p m√£ kh·ªëi.',
        showSearchSection: false,
        sinhVienSearchMode: false,
        diemSinhVienSearchMode: false,
        ploProgressMode: false,
        allStudentsProgressMode: false
      });
    }

    console.log(`\nüìä B·∫ÆT ƒê·∫¶U T·∫†O BI·ªÇU ƒê·ªí CHO KH·ªêI: ${maKhoi}`);

    // Ki·ªÉm tra cache tr∆∞·ªõc
    let cachedData = loadDiagramFromCache(maKhoi);
    if (cachedData) {
      const endTime = Date.now();
      
      return res.render('index', {
        title: 'Bi·ªÉu ƒë·ªì PLO',
        diagramMode: true,
        maKhoiQuery: maKhoi,
        chartData: cachedData.chartData,
        chartStats: cachedData.stats,
        showSearchSection: false,
        sinhVienSearchMode: false,
        diemSinhVienSearchMode: false,
        ploProgressMode: false,
        allStudentsProgressMode: false,
        cacheStatus: '‚ö° D·ªØ li·ªáu t·ª´ cache',
        processingTime: endTime - startTime
      });
    }

    // Kh√¥ng c√≥ cache - t√≠nh to√°n m·ªõi
    console.log(`üîÑ T√≠nh to√°n m·ªõi diagram cho kh·ªëi ${maKhoi}`);
    
    const chartResult = await generatePLOStatistics(maKhoi);
    
    if (!chartResult.success) {
      return res.render('index', {
        title: 'Bi·ªÉu ƒë·ªì PLO',
        diagramMode: true,
        maKhoiQuery: maKhoi,
        error: chartResult.error,
        showSearchSection: false,
        sinhVienSearchMode: false,
        diemSinhVienSearchMode: false,
        ploProgressMode: false,
        allStudentsProgressMode: false
      });
    }

    // L∆∞u v√†o cache
    saveDiagramToCache(maKhoi, chartResult.data);

    const endTime = Date.now();
    console.log(`‚úÖ Ho√†n th√†nh t·∫°o bi·ªÉu ƒë·ªì trong ${endTime - startTime}ms`);
    
    res.render('index', {
      title: 'Bi·ªÉu ƒë·ªì PLO',
      diagramMode: true,
      maKhoiQuery: maKhoi,
      chartData: chartResult.data.chartData,
      chartStats: chartResult.data.stats,
      showSearchSection: false,
      sinhVienSearchMode: false,
      diemSinhVienSearchMode: false,
      ploProgressMode: false,
      allStudentsProgressMode: false,
      cacheStatus: 'üîÑ T√≠nh to√°n m·ªõi',
      processingTime: endTime - startTime
    });
    
  } catch (error) {
    console.error('Diagram generation error:', error);
    res.render('index', {
      title: 'Bi·ªÉu ƒë·ªì PLO',
      error: 'ƒê√£ x·∫£y ra l·ªói khi t·∫°o bi·ªÉu ƒë·ªì: ' + error.message,
      diagramMode: true,
      maKhoiQuery: req.body.maKhoi,
      showSearchSection: false,
      sinhVienSearchMode: false,
      diemSinhVienSearchMode: false,
      ploProgressMode: false,
      allStudentsProgressMode: false
    });
  }
};

// FUNCTION CH√çNH 
async function generatePLOStatistics(maKhoi) {
  try {
    // 1. L·∫•y danh s√°ch sinh vi√™n t·ª´ HienDienSV
    const allHienDienRecords = await HienDienSV.find({ MaKhoi: maKhoi }).lean();
    const validYearData = getValidStudentsByYearWithDuplication(allHienDienRecords);
    const sortedNamHK = Object.keys(validYearData).map(n => parseInt(n)).sort((a, b) => a - b);
    
    if (sortedNamHK.length === 0) {
      return {
        success: false,
        error: `Kh√¥ng t√¨m th·∫•y sinh vi√™n h·ª£p l·ªá cho m√£ kh·ªëi ${maKhoi}`
      };
    }

    // 2. L·∫•y danh s√°ch PLO
    const tieuChiList = await TieuChiDauRa.find({ MaKhoi: maKhoi }).lean();
    if (!tieuChiList || tieuChiList.length === 0) {
      return {
        success: false,
        error: `Kh√¥ng t√¨m th·∫•y ti√™u ch√≠ PLO cho m√£ kh·ªëi ${maKhoi}`
      };
    }

    const ploGroups = {};
    tieuChiList.forEach(tc => {
      if (!ploGroups[tc.MaPLO]) {
        ploGroups[tc.MaPLO] = [];
      }
      ploGroups[tc.MaPLO].push(tc.MaTieuChi);
    });

    // 3. T·∫°o th·ªëng k√™ cho t·ª´ng PLO
    const chartData = [];
    const maxStudentsPerYear = Math.max(...Object.values(validYearData).map(data => data.totalStudents));

    for (const [plo, tieuChiIds] of Object.entries(ploGroups)) {
      const attemptedAllLine = [];  // ƒê√£ thi h·∫øt
      const completedAllLine = [];  // Ho√†n th√†nh

      for (const namHK of sortedNamHK) {
        const yearData = validYearData[namHK];
        
        if (!yearData || yearData.validStudents.length === 0) {
          attemptedAllLine.push([namHK, 0]);
          completedAllLine.push([namHK, 0]);
          continue;
        }

        const semesterStats = await calculatePLOStatsForSemesterUsingExistingLogic(
          yearData.validStudents,
          namHK,
          maKhoi,
          plo
        );

        attemptedAllLine.push([namHK, semesterStats.attemptedAllPercentage]);
        completedAllLine.push([namHK, semesterStats.completedAllPercentage]);
      }

      chartData.push({
        plo: plo,
        ploName: `PLO ${plo}`,
        achievedLine: {
          name: `PLO ${plo} - ƒê√£ thi h·∫øt`,
          data: attemptedAllLine,
          color: 'solid',
          description: 'T·ª∑ l·ªá sinh vi√™n ƒë√£ thi h·∫øt t·∫•t c·∫£ m√¥n'
        },
        completedLine: {
          name: `PLO ${plo} - Ho√†n th√†nh`,
          data: completedAllLine,
          color: 'light',
          description: 'T·ª∑ l·ªá sinh vi√™n ho√†n th√†nh PLO (ƒë·∫°t ƒëi·ªÉm chu·∫©n)'
        }
      });
    }

    return {
      success: true,
      data: {
        chartData,
        stats: {
          totalStudents: maxStudentsPerYear,
          totalPLOs: Object.keys(ploGroups).length,
          timeRange: {
            from: ploProgressController.formatNamHK(sortedNamHK[0]),
            to: ploProgressController.formatNamHK(sortedNamHK[sortedNamHK.length - 1])
          }
        }
      }
    };

  } catch (error) {
    console.error('Error in generatePLOStatistics:', error);
    return {
      success: false,
      error: `L·ªói t·∫°o th·ªëng k√™ PLO: ${error.message}`
    };
  }
}

  // ‚úÖ H√ÄM M·ªöI: L·∫§Y SINH VI√äN V·ªöI DUPLICATION LOGIC CHO HIENDIENSV = 3
  function getValidStudentsByYearWithDuplication(hienDienRecords) {
    const validYearData = {};
    const studentStatusMap = {}; // Theo d√µi status cu·ªëi c√πng c·ªßa m·ªói sinh vi√™n

    // 1. Thu th·∫≠p t·∫•t c·∫£ d·ªØ li·ªáu v√† x√°c ƒë·ªãnh status cu·ªëi c√πng
    hienDienRecords.forEach(record => {
      const namHK = record.NamHocKy;
      const maSV = record.MaSV;
      const hienDienStatus = record.HienDienSV;

      if (!validYearData[namHK]) {
        validYearData[namHK] = {
          validStudents: [],
          totalStudents: 0
        };
      }

      validYearData[namHK].totalStudents++;

      // Theo d√µi status c·ªßa sinh vi√™n qua c√°c nƒÉm
      if (!studentStatusMap[maSV]) {
        studentStatusMap[maSV] = [];
      }
      studentStatusMap[maSV].push({ namHK, status: hienDienStatus });

      // Ch·ªâ l·∫•y sinh vi√™n c√≥ HienDienSV = 0 ho·∫∑c 3
      if (hienDienStatus === 0 || hienDienStatus === 3) {
        if (!validYearData[namHK].validStudents.includes(maSV)) {
          validYearData[namHK].validStudents.push(maSV);
        }
      }
    });

    // 2. X·ª≠ l√Ω duplication cho sinh vi√™n c√≥ status = 3
    const allNamHK = Object.keys(validYearData).map(n => parseInt(n)).sort((a, b) => a - b);
    const latestNamHK = allNamHK[allNamHK.length - 1];

    Object.keys(studentStatusMap).forEach(maSV => {
      const studentRecords = studentStatusMap[maSV].sort((a, b) => a.namHK - b.namHK);
      let lastValidStatus = null;
      let lastValidNamHK = null;

      // T√¨m status cu·ªëi c√πng h·ª£p l·ªá (0 ho·∫∑c 3)
      for (const record of studentRecords) {
        if (record.status === 0 || record.status === 3) {
          lastValidStatus = record.status;
          lastValidNamHK = record.namHK;
        }
      }

      // ‚úÖ N·∫æU SINH VI√äN C√ì STATUS = 3, DUPLICATE T·ªöI NƒÇM M·ªöI NH·∫§T
      if (lastValidStatus === 3) {
        for (const namHK of allNamHK) {
          if (namHK > lastValidNamHK && namHK <= latestNamHK) {
            if (!validYearData[namHK].validStudents.includes(maSV)) {
              validYearData[namHK].validStudents.push(maSV);
            }
          }
        }
      }
    });

    // 3. Debug th√¥ng tin v·ªÅ HienDienSV = 1 (kh√¥ng c√≥ ƒëi·ªÉm)
    const status1Students = hienDienRecords.filter(r => r.HienDienSV === 1);
    if (status1Students.length > 0) {
      console.log(`\nüìã T√¨m th·∫•y ${status1Students.length} sinh vi√™n c√≥ HienDienSV = 1 (kh√¥ng t√≠nh v√†o th·ªëng k√™):`);
      status1Students.slice(0, 5).forEach(r => {
        console.log(`   ${r.MaSV} - ${ploProgressController.formatNamHK(r.NamHocKy)}`);
      });
      if (status1Students.length > 5) {
        console.log(`   ... v√† ${status1Students.length - 5} sinh vi√™n kh√°c`);
      }
    }

    return validYearData;
  }

  // H√ÄM T√çNH TH·ªêNG K√ä PLO (ploProgressController)
  async function calculatePLOStatsForSemesterUsingExistingLogic(validStudents, namHK, maKhoi, plo) {
    let attemptedAllCount = 0;  // ƒê√£ thi h·∫øt
    let completedAllCount = 0;  // Ho√†n th√†nh

    for (const maSV of validStudents) {
      try {
        const studentPLOData = await getStudentPLODataUsingExistingLogic(maSV, maKhoi, namHK);
        
        if (studentPLOData && studentPLOData.plos && studentPLOData.plos[plo]) {
          const ploData = studentPLOData.plos[plo];
          
          //LOGIC: CH·ªà C·∫¶N TR·ªåNG S·ªê TUY·ªÜT ƒê·ªêI > 0.999
          const hasAttemptedAll = ploData.tongTrongSoSinhVienCo > 0.999;
          const hasCompletedPLO = ploData.trangThaiDat === true && ploData.tongTrongSoSinhVienCo > 0.999;
          
          if (hasAttemptedAll) {
            attemptedAllCount++;
          }
          
          if (hasCompletedPLO) {
            completedAllCount++;
          }
        }
      } catch (error) {
        console.log(`‚ùå L·ªói t√≠nh PLO ${plo} cho sinh vi√™n ${maSV}:`, error.message);
      }
    }

    const totalValidStudents = validStudents.length;
    const attemptedAllPercentage = totalValidStudents > 0 
      ? Math.round((attemptedAllCount / totalValidStudents) * 100) 
      : 0;
    const completedAllPercentage = totalValidStudents > 0 
      ? Math.round((completedAllCount / totalValidStudents) * 100) 
      : 0;

    return {
      totalValidStudents,
      attemptedAllCount,
      completedAllCount,
      attemptedAllPercentage,
      completedAllPercentage
    };
  }

  // H√ÄM L·∫§Y D·ªÆ LI·ªÜU PLO C·ª¶A SINH VI√äN S·ª¨ D·ª§NG LOGIC C√ì S·∫¥N
  async function getStudentPLODataUsingExistingLogic(maSV, maKhoi, targetNamHK) {
    try {
      // L·∫•y th√¥ng tin ch∆∞∆°ng tr√¨nh v√† ƒëi·ªÉm chu·∫©n
      const chuongTrinh = await ChuongTrinh.findOne({ MaKhoi: maKhoi });
      if (!chuongTrinh) return null;
      const diemChon = chuongTrinh.DiemChon;

      // L·∫•y danh s√°ch PLO v√† ti√™u ch√≠
      const tieuChiList = await TieuChiDauRa.find({ MaKhoi: maKhoi });
      const ploGroups = {};
      
      tieuChiList.forEach(tc => {
        if (!ploGroups[tc.MaPLO]) {
          ploGroups[tc.MaPLO] = [];
        }
        ploGroups[tc.MaPLO].push(tc.MaTieuChi);
      });

      // L·∫•y th√¥ng tin m√¥n h·ªçc v√† ti√™u ch√≠
      const monHocTieuChiList = await MonHocTieuChi.find({
        MaTieuChi: { $in: tieuChiList.map(tc => tc.MaTieuChi) }
      });

      // L·∫•y ƒëi·ªÉm sinh vi√™n T·ªöI SEMESTER N√ÄY
      const diemSinhVienList = await DiemSinhVien.find({ 
        MaSV: maSV,
        NamHK: { $lte: targetNamHK }
      });

      // T·∫°o object sinh vi√™n
      const sinhVien = {
        MaSV: maSV,
        plos: {}
      };

      // T√≠nh to√°n cho t·ª´ng PLO S·ª¨ D·ª§NG LOGIC C√ì S·∫¥N
      for (const [plo, tieuChiIds] of Object.entries(ploGroups)) {
        const relatedMonHoc = monHocTieuChiList.filter(mh => 
          tieuChiIds.includes(mh.MaTieuChi)
        );

        const tongTrongSoLyThuyet = relatedMonHoc.reduce((sum, mh) => sum + mh.TrongSo, 0);
        
        sinhVien.plos[plo] = {
          tongTrongSoLyThuyet: tongTrongSoLyThuyet,
          tongTrongSoSinhVienCo: 0,
          tongDiemSinhVien: 0,
          diemChuanCoTrongSo: 0,
          trangThaiDat: false,
          chiTietMonHoc: {}
        };

        // X·ª≠ l√Ω t·ª´ng m√¥n h·ªçc
        for (const monHoc of relatedMonHoc) {
          const maMH = monHoc.MaMH;
          const trongSo = parseFloat(monHoc.TrongSo) || 0;
          const loaiDiem = monHoc.LoaiDiem || 'CK';

          // T√¨m ƒëi·ªÉm sinh vi√™n cho m√¥n h·ªçc n√†y
          const diemRecords = diemSinhVienList.filter(d => d.MaMH === maMH);

          let bestScore = null;
          let bestNamHK = null;

          // Ch·ªçn ƒëi·ªÉm cao nh·∫•t n·∫øu c√≥ nhi·ªÅu l·∫ßn thi
          for (const diemRecord of diemRecords) {
            const diem = ploProgressController.getDiemTheoLoaiDiem(diemRecord, loaiDiem);

            if (diem !== null && (bestScore === null || diem > bestScore)) {
              bestScore = diem;
              bestNamHK = parseInt(diemRecord.NamHK);
            }
          }

          const coGiaTri = bestScore !== null;
          const diemCoTrongSo = coGiaTri ? (bestScore * trongSo) : 0;

          sinhVien.plos[plo].chiTietMonHoc[maMH] = {
            trongSo: trongSo,
            loaiDiem: loaiDiem,
            status: coGiaTri ? 'co_diem' : 'chua_co_diem',
            diem: bestScore || 0,
            diemCoTrongSo: diemCoTrongSo,
            namHK: bestNamHK
          };

          if (coGiaTri) {
            sinhVien.plos[plo].tongTrongSoSinhVienCo += trongSo;
            sinhVien.plos[plo].tongDiemSinhVien += diemCoTrongSo;
          }
        }

        // X√°c ƒë·ªãnh tr·∫°ng th√°i ƒë·∫°t PLO
        // T√çNH ƒêI·ªÇM CHU·∫®N ƒê√öNG D·ª∞A TR√äN TR·ªåNG S·ªê C√ì ƒêI·ªÇM
      sinhVien.plos[plo].diemChuanCoTrongSo = diemChon * sinhVien.plos[plo].tongTrongSoSinhVienCo;
      // X√°c ƒë·ªãnh tr·∫°ng th√°i ƒë·∫°t PLO
      sinhVien.plos[plo].trangThaiDat = 
        sinhVien.plos[plo].tongDiemSinhVien >= sinhVien.plos[plo].diemChuanCoTrongSo;
            }

      return sinhVien;

    } catch (error) {
      console.error('Error in getStudentPLODataUsingExistingLogic:', error);
      return null;
    }
  }