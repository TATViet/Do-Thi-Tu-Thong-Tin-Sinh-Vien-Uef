// controllers/allStudentsProgressController.js

const TieuChiDauRa = require('../models/tieuChiDauRa');
const MonHocTieuChi = require('../models/MonHocTieuChi');
const HienDienSV = require('../models/HienDienSV');
const DiemSinhVien = require('../models/DiemSinhVien');
const ChuongTrinh = require('../models/ChuongTrinh');

// Import helper functions t·ª´ ploProgressController
const ploProgressController = require('./ploProgressController');

// Cache cho t·∫•t c·∫£ sinh vi√™n
const allStudentsCache = new Map();

function getAllStudentsCacheKey(maKhoi) {
  return `all_students_${maKhoi}`;
}

function saveAllStudentsToCache(maKhoi, data) {
  const key = getAllStudentsCacheKey(maKhoi);
  const cacheData = {
    timestamp: Date.now(),
    data: data
  };
  allStudentsCache.set(key, cacheData);
  console.log(`üíæ ƒê√£ cache t·∫•t c·∫£ sinh vi√™n cho kh·ªëi ${maKhoi}`);
}

function loadAllStudentsFromCache(maKhoi) {
  const key = getAllStudentsCacheKey(maKhoi);
  const cacheData = allStudentsCache.get(key);
  
  if (cacheData) {
    const ageMinutes = (Date.now() - cacheData.timestamp) / (1000 * 60);
    console.log(`üìÅ T·∫£i cache t·∫•t c·∫£ sinh vi√™n kh·ªëi ${maKhoi} (${ageMinutes.toFixed(1)} ph√∫t tr∆∞·ªõc)`);
    return cacheData.data;
  }
  return null;
}

// Hi·ªÉn th·ªã form t·∫•t c·∫£ sinh vi√™n
exports.getAllStudentsProgressForm = async (req, res) => {
  try {
    res.render('index', { 
      title: 'Theo d√µi ti·∫øn tr√¨nh PLO c·ªßa t·∫•t c·∫£ sinh vi√™n',
      allStudentsProgressMode: true,
      showSearchSection: false,
      sinhVienSearchMode: false,
      diemSinhVienSearchMode: false,
      ploProgressMode: false
    });
  } catch (error) {
    console.error('Error loading all students progress form:', error);
    res.render('index', { 
      title: 'Theo d√µi ti·∫øn tr√¨nh PLO c·ªßa t·∫•t c·∫£ sinh vi√™n',
      error: 'ƒê√£ x·∫£y ra l·ªói khi t·∫£i trang ti·∫øn tr√¨nh t·∫•t c·∫£ sinh vi√™n.',
      allStudentsProgressMode: true,
      showSearchSection: false
    });
  }
};

// T√¨m ki·∫øm t·∫•t c·∫£ sinh vi√™n
exports.searchAllStudentsProgress = async (req, res) => {
  const startTime = Date.now();
  
  try {
    const maKhoi = req.body.maKhoi;
    
    if (!maKhoi) {
      return res.render('index', {
        title: 'Theo d√µi ti·∫øn tr√¨nh PLO c·ªßa t·∫•t c·∫£ sinh vi√™n',
        allStudentsProgressMode: true,
        maKhoiQuery: '',
        error: 'Vui l√≤ng nh·∫≠p m√£ kh·ªëi.',
        showSearchSection: false,
        sinhVienSearchMode: false,
        diemSinhVienSearchMode: false,
        ploProgressMode: false
      });
    }

    console.log(`\nüîç B·∫ÆT ƒê·∫¶U X·ª¨ L√ù T·∫§T C·∫¢ SINH VI√äN - Kh·ªëi: ${maKhoi}`);

    // Ki·ªÉm tra cache tr∆∞·ªõc
    let cachedData = loadAllStudentsFromCache(maKhoi);
    if (cachedData) {
      const endTime = Date.now();
      
      return res.render('index', {
        title: 'Theo d√µi ti·∫øn tr√¨nh PLO c·ªßa t·∫•t c·∫£ sinh vi√™n',
        allStudentsProgressMode: true,
        maKhoiQuery: maKhoi,
        allStudentsProgress: cachedData.allStudentsProgress,
        ploGroups: cachedData.ploGroups,
        namHKList: cachedData.namHKList,
        totalStudents: cachedData.totalStudents,
        diemChon: cachedData.diemChon,
        showSearchSection: false,
        sinhVienSearchMode: false,
        diemSinhVienSearchMode: false,
        ploProgressMode: false,
        cacheStatus: '‚ö° D·ªØ li·ªáu t·ª´ cache',
        processingTime: endTime - startTime
      });
    }

    // Kh√¥ng c√≥ cache - t√≠nh to√°n m·ªõi
    console.log(`üîÑ T√≠nh to√°n m·ªõi cho t·∫•t c·∫£ sinh vi√™n kh·ªëi ${maKhoi}`);
    
    const result = await processAllStudentsProgress(maKhoi);
    
    if (!result.success) {
      return res.render('index', {
        title: 'Theo d√µi ti·∫øn tr√¨nh PLO c·ªßa t·∫•t c·∫£ sinh vi√™n',
        allStudentsProgressMode: true,
        maKhoiQuery: maKhoi,
        error: result.error,
        showSearchSection: false,
        sinhVienSearchMode: false,
        diemSinhVienSearchMode: false,
        ploProgressMode: false
      });
    }

    // L∆∞u v√†o cache
    saveAllStudentsToCache(maKhoi, result.data);
    
    const endTime = Date.now();
    console.log(`‚úÖ Ho√†n th√†nh t·∫•t c·∫£ sinh vi√™n trong ${endTime - startTime}ms`);
    
    res.render('index', {
      title: 'Theo d√µi ti·∫øn tr√¨nh PLO c·ªßa t·∫•t c·∫£ sinh vi√™n',
      allStudentsProgressMode: true,
      maKhoiQuery: maKhoi,
      allStudentsProgress: result.data.allStudentsProgress,
      ploGroups: result.data.ploGroups,
      namHKList: result.data.namHKList,
      totalStudents: result.data.totalStudents,
      diemChon: result.data.diemChon,
      showSearchSection: false,
      sinhVienSearchMode: false,
      diemSinhVienSearchMode: false,
      ploProgressMode: false,
      cacheStatus: 'üîÑ T√≠nh to√°n m·ªõi',
      processingTime: endTime - startTime
    });
    
  } catch (error) {
    console.error('All students progress search error:', error);
    res.render('index', {
      title: 'Theo d√µi ti·∫øn tr√¨nh PLO c·ªßa t·∫•t c·∫£ sinh vi√™n',
      error: 'ƒê√£ x·∫£y ra l·ªói khi t√¨m ki·∫øm ti·∫øn tr√¨nh t·∫•t c·∫£ sinh vi√™n: ' + error.message,
      allStudentsProgressMode: true,
      maKhoiQuery: req.body.maKhoi,
      showSearchSection: false,
      sinhVienSearchMode: false,
      diemSinhVienSearchMode: false,
      ploProgressMode: false
    });
  }
};

// H√†m x·ª≠ l√Ω t·∫•t c·∫£ sinh vi√™n
async function processAllStudentsProgress(maKhoi) {
  try {
    // 1. L·∫•y th√¥ng tin ch∆∞∆°ng tr√¨nh v√† ƒëi·ªÉm chu·∫©n
    const chuongTrinh = await ChuongTrinh.findOne({ MaKhoi: maKhoi });
    if (!chuongTrinh || !chuongTrinh.DiemChon) {
      return {
        success: false,
        error: `Kh√¥ng t√¨m th·∫•y ch∆∞∆°ng tr√¨nh ho·∫∑c ƒëi·ªÉm chu·∫©n cho m√£ kh·ªëi ${maKhoi}`
      };
    }
    const diemChon = chuongTrinh.DiemChon;

    // 2. L·∫§Y DANH S√ÅCH MaSV ƒê·ªòC NH·∫§T T·ª™ HIENDIENSVS
    const uniqueMaSVList = await HienDienSV.distinct('MaSV', { MaKhoi: maKhoi });
    
    if (!uniqueMaSVList || uniqueMaSVList.length === 0) {
      return {
        success: false,
        error: `Kh√¥ng t√¨m th·∫•y sinh vi√™n n√†o thu·ªôc m√£ kh·ªëi "${maKhoi}".`
      };
    }

    // T·∫°o danh s√°ch sinh vi√™n t·ª´ MaSV ƒë·ªôc nh·∫•t
    const sinhVienList = uniqueMaSVList.map(maSV => ({ MaSV: maSV }));
    
    //console.log(`üë• T√¨m th·∫•y ${sinhVienList.length} sinh vi√™n ƒë·ªôc nh·∫•t trong kh·ªëi ${maKhoi}`);

    // 3. L·∫•y PLO groups
    const tieuChiList = await TieuChiDauRa.find({ MaKhoi: maKhoi }).lean();
    const ploGroups = {};
    tieuChiList.forEach(tc => {
      if (!ploGroups[tc.MaPLO]) {
        ploGroups[tc.MaPLO] = [];
      }
      ploGroups[tc.MaPLO].push(tc.MaTieuChi);
    });

    // 4. T·∫°o timeline NamHK
    const allNamHK = await DiemSinhVien.distinct('NamHK');
    const sortedNamHK = allNamHK.map(nk => parseInt(nk)).sort((a, b) => a - b);
    const namHKList = sortedNamHK.map(namHK => ({
      value: namHK,
      formatted: ploProgressController.formatNamHK(namHK)
    }));

    // 5. X·ª≠ l√Ω t·ª´ng sinh vi√™n
    const allStudentsProgress = [];
    
    for (let i = 0; i < sinhVienList.length; i++) {
      const student = sinhVienList[i];
      //console.log(`üîÑ X·ª≠ l√Ω ${i + 1}/${sinhVienList.length}: ${student.MaSV}`);
      
      try {
        const progressResult = await calculatePLOProgressForStudent(
          student.MaSV, 
          maKhoi, 
          diemChon, 
          student, 
          ploGroups, 
          tieuChiList,
          sortedNamHK
        );
        
        if (progressResult.success) {
          allStudentsProgress.push({
            sinhVien: student,
            ploProgress: progressResult.data
          });
        } else {
          console.log(`‚ùå L·ªói x·ª≠ l√Ω sinh vi√™n ${student.MaSV}: ${progressResult.error}`);
        }
      } catch (error) {
        console.log(`‚ùå Exception x·ª≠ l√Ω sinh vi√™n ${student.MaSV}:`, error.message);
      }
    }

    return {
      success: true,
      data: {
        allStudentsProgress,
        ploGroups,
        namHKList,
        totalStudents: allStudentsProgress.length,
        diemChon
      }
    };

  } catch (error) {
    console.error('Error in processAllStudentsProgress:', error);
    return {
      success: false,
      error: `ƒê√£ x·∫£y ra l·ªói khi x·ª≠ l√Ω t·∫•t c·∫£ sinh vi√™n: ${error.message}`
    };
  }
}

// T√≠nh PLO cho t·ª´ng sinh vi√™n V·ªöI CUMULATIVE PROGRESS (FIX: KH·ªûI T·∫†O T·∫§T C·∫¢ SEMESTER V·ªöI 0)
async function calculatePLOProgressForStudent(maSV, maKhoi, diemChon, sinhVien, ploGroups, tieuChiList, sortedNamHK) {
  try {
    // L·∫•y t·∫•t c·∫£ ƒëi·ªÉm c·ªßa sinh vi√™n
    const diemSinhVienList = await DiemSinhVien.find({ MaSV: maSV }).lean();

    // L·∫•y th√¥ng tin m√¥n h·ªçc v√† ti√™u ch√≠
    const monHocTieuChiList = await MonHocTieuChi.find({
      MaTieuChi: { $in: tieuChiList.map(tc => tc.MaTieuChi) }
    }).lean();

    const results = {};

    // T√≠nh t·ª´ng PLO
    for (const [plo, tieuChiIds] of Object.entries(ploGroups)) {
      // L·∫•y m√¥n h·ªçc li√™n quan ƒë·∫øn PLO n√†y
      const relatedMonHoc = monHocTieuChiList.filter(mh => 
        tieuChiIds.includes(mh.MaTieuChi)
      );

      // T√≠nh to√°n t·ªïng tr·ªçng s·ªë l√Ω thuy·∫øt
      const tongTrongSoLyThuyet = relatedMonHoc.reduce((sum, mh) => sum + mh.TrongSo, 0);

      // X·ª≠ l√Ω t·ª´ng m√¥n h·ªçc
      const courseDetails = {};
      for (const monHoc of relatedMonHoc) {
        const maMH = monHoc.MaMH;
        const trongSo = parseFloat(monHoc.TrongSo) || 0;
        const loaiDiem = monHoc.LoaiDiem || 'CK';

        // T√¨m ƒëi·ªÉm sinh vi√™n cho m√¥n h·ªçc n√†y
        const diemRecords = diemSinhVienList.filter(d => d.MaMH === maMH);

        let bestScore = null;
        let bestNamHK = null;

        // Ch·ªçn ƒëi·ªÉm cao nh·∫•t n·∫øu c√≥ nhi·ªÅu l·∫ßn thi
        for (const diemRecord of diemRecords) {
          const diem = ploProgressController.getDiemTheoLoaiDiem(diemRecord, loaiDiem);

          if (diem !== null && (bestScore === null || diem > bestScore)) {
            bestScore = diem;
            bestNamHK = parseInt(diemRecord.NamHK);
          }
        }

        courseDetails[maMH] = {
          trongSo: trongSo,
          loaiDiem: loaiDiem,
          status: bestScore !== null ? 'co_diem' : 'chua_co_diem',
          diem: bestScore || 0,
          diemCoTrongSo: bestScore ? (bestScore * trongSo) : 0,
          namHK: bestNamHK
        };
      }

      // B∆Ø·ªöC 1: T√çNH ƒêI·ªÇM TH·ª∞C T·∫æ CHO T·ª™NG SEMESTER
      const semesterActualData = {};
      for (const namHK of sortedNamHK) {
        semesterActualData[namHK] = {
          achievedCourses: 0,
          cumulativeScore: 0
        };
      }

      // ƒêi·ªÅn data th·ª±c t·∫ø t·ª´ courseDetails
      Object.values(courseDetails).forEach(courseDetail => {
        if (courseDetail.status === 'co_diem' && courseDetail.namHK) {
          const namHK = courseDetail.namHK;
          if (semesterActualData[namHK]) {
            semesterActualData[namHK].achievedCourses++;
            semesterActualData[namHK].cumulativeScore += courseDetail.diemCoTrongSo;
          }
        }
      });

      // B∆Ø·ªöC 2: T√çNH CUMULATIVE PROGRESS CHO T·ª™NG SEMESTER
      const cumulativeProgress = {};
      let runningAchievedCourses = 0;
      let runningCumulativeScore = 0;
      
      for (const namHK of sortedNamHK) {
        const actualData = semesterActualData[namHK];
        
        // C·ªông d·ªìn t·ª´ semester n√†y
        runningAchievedCourses += actualData.achievedCourses;
        runningCumulativeScore += actualData.cumulativeScore;
        
        // T√çNH TR·ªåNG S·ªê C√ì ƒêI·ªÇM ƒê√É T√çCH L≈®Y ƒê·∫æN SEMESTER N√ÄY
        let tongTrongSoCoTichLuy = 0;
        Object.values(courseDetails).forEach(courseDetail => {
          if (courseDetail.status === 'co_diem' && courseDetail.namHK && courseDetail.namHK <= namHK) {
            tongTrongSoCoTichLuy += courseDetail.trongSo;
          }
        });
        
        const requiredScore = diemChon * tongTrongSoCoTichLuy;
        const isAchieved = runningCumulativeScore >= requiredScore;
        const isCompleted = (tongTrongSoCoTichLuy > 0.99) && isAchieved;
        
        // C·∫≠p nh·∫≠t cumulative progress
        cumulativeProgress[namHK] = {
          achievedCourses: runningAchievedCourses,
          totalCourses: relatedMonHoc.length,
          cumulativeScore: runningCumulativeScore,
          requiredScore: requiredScore,
          isAchieved: isAchieved,
          isCompleted: isCompleted,
          hasProgress: actualData.achievedCourses > 0 || runningAchievedCourses > 0,
          tongTrongSoCoTichLuy: tongTrongSoCoTichLuy
        };
      }

      // L∆∞u k·∫øt qu·∫£ cho PLO n√†y
      results[plo] = {
        tongTrongSoLyThuyet: tongTrongSoLyThuyet,
        chiTietMonHoc: courseDetails,
        cumulativeProgress: cumulativeProgress
      };
    }

    return {
      success: true,
      data: results
    };

  } catch (error) {
    return {
      success: false,
      error: error.message
    };
  }
}

// Export
exports.processAllStudentsProgress = processAllStudentsProgress;